{{=[[ ]]=}}
#include "config.h"
#include <dlfcn.h>
#include <sys/socket.h>
#include <error.h>
#include <errno.h>
#include <string.h>
#include <stdarg.h>

#include "shim.h"
#include "rpc.h"
#include "fixups.h"

#ifdef __APPLE__
struct interpose {
	const void *replacment;
	const void *replacee;
};
#else
__attribute__((regparm (3))) extern void *_dl_sym(void *handle,
	const char *symbol, const void *rtraddr);
#endif

#define DIRENT_SIZE(unused) sizeof(struct dirent)
#define SAFE_STRLEN(p) (p ? real_strlen(p) : 0)
[[#functions]]

[[type]]
#ifdef __APPLE__
retrace_impl_[[name]]([[#params]][[type]][[name]][[^last]], [[/last]][[/params]][[#variadic]], ...[[/variadic]])
#else
([[name]])([[#params]][[type]][[name]][[^last]], [[/last]][[/params]][[#variadic]], ...[[/variadic]])
#endif
{
	struct call_header call_header = {RPC_PRECALL, RPC_[[name]]};
	struct redirect_header redirect_header;
	struct iovec iov[1 + [[max-rpcvalues]]];
	struct msghdr msg = {NULL, 0, iov, 0, NULL, 0, 0};
	char _buf[32768];
[[#variadic]]
	va_list ap;
[[/variadic]]
[[#result]]
	[[type]]_result;
[[/result]]
[[#extras]]
	[[type]][[name]];
[[/extras]]

[[#extras]]
[[#pre]]
	[[name]] = [[& init]];
[[/pre]]
[[/extras]]

	iov[0].iov_base = &call_header;
	iov[0].iov_len = sizeof(call_header);
	msg.msg_iovlen = 1;
[[#rpcvalues]]
[[#pre]]
	iov[msg.msg_iovlen].iov_base = [[& base]];
	iov[msg.msg_iovlen++].iov_len = [[& len]];
[[/pre]]
[[/rpcvalues]]

	do_send(&msg);

	iov[0].iov_base = &redirect_header;
	iov[0].iov_len = sizeof(redirect_header);
	msg.msg_iovlen = 1;
[[#rpcvalues]]
[[#param]]
	iov[msg.msg_iovlen].iov_base = [[& base]];
	iov[msg.msg_iovlen++].iov_len = [[& len]];
[[/param]]
[[/rpcvalues]]
	iov[msg.msg_iovlen].iov_base = _buf;
	iov[msg.msg_iovlen++].iov_len = sizeof(_buf);
	
	do_recv(&msg);

	if (!redirect_header.postredirect) {
[[#preredirect-data]]
		if (redirect_header.preredirect) {
			char *p = _buf;
[[#rpcvalues]]
[[#param-data]]
[[#pre]]
			_save_[[name]] = [[name]];
			if ([[name]] != NULL) {
				[[name]] = (void *)p;
				p += [[& len]];
			}
[[/pre]]
[[/param-data]]
[[/rpcvalues]]
		}
[[/preredirect-data]]

[[#variadic]]
		va_start(ap, [[last_param]]);
		[[#result]]_result = [[/result]][[variadic]]([[#params]][[name]], [[/params]]ap);
		va_end(ap);
[[/variadic]]
[[^variadic]]
		[[#result]]_result = [[/result]]real_[[name]]([[#params]][[name]][[^last]], [[/last]][[/params]]);
[[/variadic]]

[[#preredirect-data]]
		if (redirect_header.preredirect) {
[[#rpcvalues]]
[[#param-data]]
[[#pre]]
			[[name]] = _save_[[name]];
[[/pre]]
[[/param-data]]
[[/rpcvalues]]
		}
[[/preredirect-data]]

[[#extras]]
[[#post]]
		[[name]] = [[init]];
[[/post]]
[[/extras]]

		call_header.call_type = RPC_POSTCALL;
		iov[0].iov_base = &call_header;
		iov[0].iov_len = sizeof(call_header);
		msg.msg_iovlen = 1;
[[#rpcvalues]]
[[#post]]
		iov[msg.msg_iovlen].iov_base = [[& base]];
		iov[msg.msg_iovlen++].iov_len = [[& len]];
[[/post]]
[[/rpcvalues]]

		do_send(&msg);

		iov[0].iov_base = &redirect_header;
		iov[0].iov_len = sizeof(redirect_header);
		iov[1].iov_base = _buf;
		iov[1].iov_len = sizeof(_buf);
		msg.msg_iovlen = 2;

		do_recv(&msg);
	}

	if (redirect_header.postredirect) {
		char *p = _buf;
[[#result]]
		memcpy(&_result, p, sizeof(_result));
		p += sizeof(_result);
[[/result]]
		memcpy(&errno, p, sizeof(errno));
		p += sizeof(errno);
[[#rpcvalues]]
[[#post]]
[[#data]]
[[^extra]]
		p = [[update]](p);
[[/extra]]
[[/data]]
[[/post]]
[[/rpcvalues]]
	}

	return[[#result]] _result[[/result]];
}

#ifdef __APPLE__
static struct interpose _interpose_[[name]] __attribute__((used, section("__DATA,__interpose"))) = {
	(const void *)(unsigned long)&retrace_impl_[[name]],
	(const void *)(unsigned long)&[[name]]
};
rtr_[[name]]_t real_[[name]] = [[name]];
#else
[[type]]
rtr_fixup_[[name]]([[#params]][[type]][[name]][[^last]], [[/last]][[/params]][[#variadic]], ...[[/variadic]])
{
	void *fn = _dl_sym(RTLD_NEXT, "[[name]]", rtr_fixup_[[name]]);
#ifdef HAVE_ATOMIC_BUILTINS
	__atomic_store_n(&real_[[name]], fn, __ATOMIC_RELAXED);
#else
	real_[[name]] = fn;
#endif
[[^variadic]]
	[[#result]]return [[/result]]real_[[name]]([[#params]][[name]][[^last]], [[/last]][[/params]]);
[[/variadic]]
[[#variadic]]
	va_list ap;
	va_start(ap, [[last_param]]);
	[[#result]][[type]]ret = [[/result]][[variadic]]([[#params]][[name]], [[/params]]ap);
	va_end(ap);
	return[[#result]] ret[[/result]];
[[/variadic]]
}
__attribute__((visibility("hidden"))) rtr_[[name]]_t real_[[name]] = rtr_fixup_[[name]];
#endif
[[/functions]]
